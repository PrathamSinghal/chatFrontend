{"version":3,"sources":["../../../../src/components/plain-button/index.ts","../../../src/common/tether-positions.tsx","../../../../src/components/tooltip/Tooltip.tsx","../../../../src/components/tooltip/CloseButton.tsx","../../../src/common/messages.js","../../../../src/components/dropdown-menu/MenuToggle.js","../../../../src/components/menu/MenuItem.tsx","../../../../src/components/menu/MenuContext.tsx","../../../../src/elements/common/Tooltip.js","../../../../src/components/dropdown-menu/DropdownMenu.js","../../../../src/icons/general/IconCaretDown.tsx","../../../../src/components/menu/Menu.tsx"],"names":["TetherPosition","TooltipTheme","TooltipPosition","injectIntl","intl","onClick","formatMessage","messages","close","className","width","height","positions","BOTTOM_CENTER","attachment","TOP_CENTER","targetAttachment","BOTTOM_LEFT","TOP_RIGHT","BOTTOM_RIGHT","TOP_LEFT","MIDDLE_LEFT","MIDDLE_RIGHT","Tooltip","props","uniqueId","React","tetherRef","current","isShown","position","onDismiss","setState","wasClosedByUser","type","event","handler","children","stopPropagation","nativeEvent","stopImmediatePropagation","fireChildEvent","key","isShownProp","isControlled","state","hasRendered","this","prevProps","prevState","document","addEventListener","handleKeyDown","removeEventListener","ariaHidden","bodyElement","constrainToScrollParent","constrainToWindow","isDisabled","isTabbable","offset","showCloseButton","stopBubble","tetherElementClassName","text","theme","childAriaLabel","getProp","isLabelMatchingTooltipText","only","showTooltip","withCloseButton","tetherPosition","constraints","componentProps","push","to","undefined","tooltipID","ERROR","onBlur","handleBlur","onFocus","handleFocus","onMouseEnter","handleMouseEnter","onMouseLeave","handleMouseLeave","tabIndex","bodyEl","HTMLElement","body","classes","classNames","CALLOUT","tetherProps","classPrefix","enabled","tooltipInner","closeTooltip","tooltip","id","handleTooltipEvent","onContextMenu","onKeyPress","role","ref","DEFAULT","defineMessages","cancel","copy","copied","done","okay","save","send","optional","pillSelectorPlaceholder","messageSelectorPlaceholder","invalidInputError","minLengthError","maxLengthError","invalidEmailError","invalidURLError","invalidUserError","requiredFieldError","invalidDateError","MenuToggle","MenuItem","preventDefault","isSelectItem","isSelected","showRadar","rest","menuItemProps","omit","onClickHandler","menuItem","closeMenu","noop","DropdownMenu","initialFocusIndex","isOpen","onMenuClose","menuButtonEl","getElementById","menuButtonID","focus","openMenuAndSetFocusIndex","KEYS","space","enter","arrowDown","arrowUp","escape","isKeyboardEvent","focusButton","menuEl","menuID","target","Node","contains","useBubble","handleDocumentClick","onMenuOpen","constrainToWindowWithPin","isResponsive","isRightAligned","tetherAttachment","tetherTargetAttachment","elements","toArray","length","Error","menuButton","menu","menuButtonProps","handleButtonClick","onKeyDown","handleButtonKeyDown","menuProps","onClose","handleMenuClose","pin","IconCaretDown","color","title","viewBox","d","fill","fillRule","MENU_ITEM_SELECTOR","TOP_LEVEL_MENU_ITEM_SELECTOR","SUBMENU_ITEM_SELECTOR","stopPropagationAndPreventDefault","Menu","isHidden","setTimeout","setFocus","isSubmenu","selector","menuItemSelector","menuItemEls","slice","call","querySelectorAll","menuItemEl","menuIndex","i","index","numMenuItems","focusIndex","getMenuItemElFromEventTarget","fireOnCloseHandler","keyboardPressed","focusNextItem","focusFirstItem","focusPreviousItem","focusLastItem","click","setMenuItemEls","setInitialFocusIndex","prevIsHidden","prevChildren","focusedMenuItemEl","isFocusedElementMissing","isFocusIndexOutOfBounds","setRef","shouldOutlineFocus","handleClick","Provider","value"],"mappings":"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","file":"static/js/2.24033d1b.chunk.js","sourcesContent":["import { PlainButtonProps as Props } from './PlainButton';\n\nexport { default } from './PlainButton';\nexport type PlainButtonProps = Props;\n","enum TetherPosition {\n    TOP_LEFT = 'top left',\n    TOP_CENTER = 'top center',\n    TOP_RIGHT = 'top right',\n    MIDDLE_LEFT = 'middle left',\n    MIDDLE_CENTER = 'middle center',\n    MIDDLE_RIGHT = 'middle right',\n    BOTTOM_LEFT = 'bottom left',\n    BOTTOM_CENTER = 'bottom center',\n    BOTTOM_RIGHT = 'bottom right',\n}\n\nexport default TetherPosition;\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport uniqueId from 'lodash/uniqueId';\nimport getProp from 'lodash/get';\nimport TetherComponent from 'react-tether';\n\nimport TetherPosition from '../../common/tether-positions';\nimport CloseButton from './CloseButton';\n\nimport './Tooltip.scss';\n\nexport enum TooltipTheme {\n    CALLOUT = 'callout',\n    DEFAULT = 'default',\n    ERROR = 'error',\n}\n\nexport enum TooltipPosition {\n    BOTTOM_CENTER = 'bottom-center',\n    BOTTOM_LEFT = 'bottom-left',\n    BOTTOM_RIGHT = 'bottom-right',\n    MIDDLE_LEFT = 'middle-left',\n    MIDDLE_RIGHT = 'middle-right',\n    TOP_CENTER = 'top-center',\n    TOP_LEFT = 'top-left',\n    TOP_RIGHT = 'top-right',\n}\n\nexport type TooltipCustomPosition = {\n    attachment: TetherPosition;\n    targetAttachment: TetherPosition;\n};\n\nconst positions = {\n    [TooltipPosition.BOTTOM_CENTER]: {\n        attachment: TetherPosition.TOP_CENTER,\n        targetAttachment: TetherPosition.BOTTOM_CENTER,\n    },\n    [TooltipPosition.BOTTOM_LEFT]: {\n        attachment: TetherPosition.TOP_RIGHT,\n        targetAttachment: TetherPosition.BOTTOM_RIGHT,\n    },\n    [TooltipPosition.BOTTOM_RIGHT]: {\n        attachment: TetherPosition.TOP_LEFT,\n        targetAttachment: TetherPosition.BOTTOM_LEFT,\n    },\n    [TooltipPosition.MIDDLE_LEFT]: {\n        attachment: TetherPosition.MIDDLE_RIGHT,\n        targetAttachment: TetherPosition.MIDDLE_LEFT,\n    },\n    [TooltipPosition.MIDDLE_RIGHT]: {\n        attachment: TetherPosition.MIDDLE_LEFT,\n        targetAttachment: TetherPosition.MIDDLE_RIGHT,\n    },\n    [TooltipPosition.TOP_CENTER]: {\n        attachment: TetherPosition.BOTTOM_CENTER,\n        targetAttachment: TetherPosition.TOP_CENTER,\n    },\n    [TooltipPosition.TOP_LEFT]: {\n        attachment: TetherPosition.BOTTOM_RIGHT,\n        targetAttachment: TetherPosition.TOP_RIGHT,\n    },\n    [TooltipPosition.TOP_RIGHT]: {\n        attachment: TetherPosition.BOTTOM_LEFT,\n        targetAttachment: TetherPosition.TOP_LEFT,\n    },\n};\n\nexport type DefaultTooltipProps = {\n    /** Whether to constrain the tooltip to the element's scroll parent. Defaults to `false` */\n    constrainToScrollParent: boolean;\n    /** Whether to constrain the tooltip to window. Defaults to `true` */\n    constrainToWindow: boolean;\n    /** Forces the tooltip to be disabled irrespecitve of it's shown state. Defaults to `false` */\n    isDisabled: boolean;\n    /** Where to position the tooltip relative to the wrapped component */\n    position: TooltipPosition | TooltipCustomPosition;\n    /** Tooltip theme */\n    theme: TooltipTheme;\n};\n\nexport type TooltipProps = {\n    /** Sets aria-hidden attribute on tooltip */\n    ariaHidden?: boolean;\n    /** An HTML element to append the tooltip container into (otherwise appends to body) */\n    bodyElement?: HTMLElement;\n    /** A React element to put the tooltip on */\n    children: React.ReactChild;\n    /** A CSS class for the tooltip */\n    className?: string;\n    /** Forces the tooltip to be shown or hidden (useful for errors) */\n    isShown?: boolean;\n    /** Whether to add tabindex=0.  Defaults to `true` */\n    isTabbable?: boolean;\n    /** A string of the form 'vert-offset horiz-offset' which controls positioning */\n    offset?: string;\n    /** Function called if the user manually dismisses the tooltip - only applies if showCloseButton is true */\n    onDismiss?: () => void;\n    /** Shows an X button to close the tooltip. Useful when tooltips are force shown with the isShown prop. */\n    showCloseButton?: boolean;\n    /** stop click|keypress event bubbling */\n    stopBubble?: boolean;\n    /** A CSS class for the tether element component */\n    tetherElementClassName?: string;\n    /** Text to show in the tooltip */\n    text?: React.ReactNode;\n} & Partial<DefaultTooltipProps>;\n\ntype State = {\n    isShown: boolean;\n    hasRendered: boolean;\n    wasClosedByUser: boolean;\n};\n\nclass Tooltip extends React.Component<TooltipProps, State> {\n    static defaultProps: DefaultTooltipProps = {\n        constrainToScrollParent: false,\n        constrainToWindow: true,\n        isDisabled: false,\n        position: TooltipPosition.TOP_CENTER,\n        theme: TooltipTheme.DEFAULT,\n    };\n\n    constructor(props: TooltipProps) {\n        super(props);\n\n        this.state = { isShown: !!props.isShown, hasRendered: false, wasClosedByUser: false };\n    }\n\n    componentDidMount() {\n        this.setState({ hasRendered: true });\n    }\n\n    componentDidUpdate(prevProps: TooltipProps, prevState: State) {\n        const isControlled = this.isControlled();\n\n        // Reset wasClosedByUser state when isShown transitions from false to true\n        if (isControlled) {\n            if (!prevProps.isShown && this.props.isShown) {\n                this.setState({ wasClosedByUser: false });\n            }\n        } else {\n            if (!prevState.isShown && this.state.isShown) {\n                // capture event so that tooltip closes before any other floating components that can be closed by\n                // \"Escape\" key(e.g. Modal, Menu, etc.)\n                document.addEventListener('keydown', this.handleKeyDown, true);\n            }\n            if (prevState.isShown && !this.state.isShown) {\n                document.removeEventListener('keydown', this.handleKeyDown, true);\n            }\n        }\n    }\n\n    componentWillUnmount() {\n        document.removeEventListener('keydown', this.handleKeyDown, true);\n    }\n\n    tooltipID = uniqueId('tooltip');\n\n    tetherRef = React.createRef<TetherComponent>();\n\n    // Instance API: Forces the radar to be repositioned\n    position = () => {\n        if (this.tetherRef.current && this.isShown()) {\n            this.tetherRef.current.position();\n        }\n    };\n\n    closeTooltip = () => {\n        const { onDismiss } = this.props;\n        this.setState({ wasClosedByUser: true });\n        if (onDismiss) {\n            onDismiss();\n        }\n    };\n\n    fireChildEvent = (type: string, event: React.SyntheticEvent<HTMLElement> | Event) => {\n        const { children } = this.props;\n        const handler = (children as React.ReactElement).props[type];\n        if (handler) {\n            handler(event);\n        }\n    };\n\n    handleTooltipEvent = (event: React.MouseEvent<HTMLElement> | React.KeyboardEvent<HTMLElement>) => {\n        event.stopPropagation();\n        event.nativeEvent.stopImmediatePropagation();\n    };\n\n    handleMouseEnter = (event: React.SyntheticEvent<HTMLElement>) => {\n        this.setState({ isShown: true });\n        this.fireChildEvent('onMouseEnter', event);\n    };\n\n    handleMouseLeave = (event: React.SyntheticEvent<HTMLElement>) => {\n        this.setState({ isShown: false });\n        this.fireChildEvent('onMouseLeave', event);\n    };\n\n    handleFocus = (event: React.SyntheticEvent<HTMLElement>) => {\n        this.setState({ isShown: true });\n        this.fireChildEvent('onFocus', event);\n    };\n\n    handleBlur = (event: React.SyntheticEvent<HTMLElement>) => {\n        this.setState({ isShown: false });\n        this.fireChildEvent('onBlur', event);\n    };\n\n    isControlled = () => {\n        const { isShown: isShownProp } = this.props;\n        return typeof isShownProp !== 'undefined';\n    };\n\n    handleKeyDown = (event: KeyboardEvent) => {\n        if (event.key === 'Escape') {\n            event.stopPropagation();\n            this.setState({ isShown: false });\n        }\n        this.fireChildEvent('onKeyDown', event);\n    };\n\n    isShown = () => {\n        const { isShown: isShownProp } = this.props;\n        const isControlled = this.isControlled();\n\n        const isShown = isControlled ? isShownProp : this.state.isShown;\n\n        const showTooltip = isShown && !this.state.wasClosedByUser && this.state.hasRendered;\n\n        return showTooltip;\n    };\n\n    render() {\n        const {\n            ariaHidden,\n            bodyElement,\n            children,\n            className,\n            constrainToScrollParent,\n            constrainToWindow,\n            isDisabled,\n            isTabbable = true,\n            offset,\n            position = TooltipPosition.TOP_CENTER,\n            showCloseButton,\n            stopBubble,\n            tetherElementClassName,\n            text,\n            theme,\n        } = this.props;\n\n        const childAriaLabel = getProp(children, 'props.aria-label');\n        const isLabelMatchingTooltipText = !!childAriaLabel && childAriaLabel === text;\n\n        // If the tooltip is disabled just render the children\n        if (isDisabled) {\n            return React.Children.only(children);\n        }\n\n        const isControlled = this.isControlled();\n        const showTooltip = this.isShown();\n\n        const withCloseButton = showCloseButton && isControlled;\n        const tetherPosition = typeof position === 'string' ? positions[position] : position;\n        const constraints = [];\n        const componentProps: {\n            [key: string]:\n                | string\n                | ((event: React.SyntheticEvent<HTMLElement>) => void)\n                | ((event: React.KeyboardEvent<HTMLElement>) => void);\n        } = {};\n\n        if (constrainToScrollParent) {\n            constraints.push({\n                to: 'scrollParent',\n                attachment: 'together',\n            });\n        }\n        if (constrainToWindow) {\n            constraints.push({\n                to: 'window',\n                attachment: 'together',\n            });\n        }\n\n        if (showTooltip && !ariaHidden) {\n            if (!isLabelMatchingTooltipText || childAriaLabel === undefined) {\n                componentProps['aria-describedby'] = this.tooltipID;\n            }\n\n            if (theme === TooltipTheme.ERROR) {\n                componentProps['aria-errormessage'] = this.tooltipID;\n            }\n        }\n        if (!isControlled) {\n            componentProps.onBlur = this.handleBlur;\n            componentProps.onFocus = this.handleFocus;\n            componentProps.onMouseEnter = this.handleMouseEnter;\n            componentProps.onMouseLeave = this.handleMouseLeave;\n\n            if (isTabbable) {\n                componentProps.tabIndex = '0';\n            }\n        }\n\n        const bodyEl = bodyElement instanceof HTMLElement ? bodyElement : document.body;\n\n        const classes = classNames('tooltip', 'bdl-Tooltip', className, {\n            'is-callout': theme === TooltipTheme.CALLOUT,\n            'is-error': theme === TooltipTheme.ERROR,\n            'with-close-button': withCloseButton,\n        });\n\n        const tetherProps: {\n            attachment: TetherPosition;\n            bodyElement: HTMLElement;\n            classPrefix: string;\n            constraints: {};\n            enabled: boolean | undefined;\n            targetAttachment: TetherPosition;\n            offset?: string;\n            className?: string;\n        } = {\n            attachment: tetherPosition.attachment,\n            bodyElement: bodyEl,\n            classPrefix: 'tooltip',\n            constraints,\n            enabled: showTooltip,\n            targetAttachment: tetherPosition.targetAttachment,\n        };\n\n        if (tetherElementClassName) {\n            tetherProps.className = tetherElementClassName;\n        }\n\n        if (offset) {\n            tetherProps.offset = offset;\n        }\n\n        const tooltipInner = (\n            <>\n                {text}\n                {withCloseButton && <CloseButton onClick={this.closeTooltip} />}\n            </>\n        );\n\n        const tooltip = stopBubble ? (\n            <div\n                className={classes}\n                id={this.tooltipID}\n                onClick={this.handleTooltipEvent}\n                onContextMenu={this.handleTooltipEvent}\n                onKeyPress={this.handleTooltipEvent}\n                onMouseEnter={this.handleMouseEnter}\n                onMouseLeave={this.handleMouseLeave}\n                role=\"presentation\"\n            >\n                <div\n                    role={theme === TooltipTheme.ERROR ? undefined : 'tooltip'}\n                    aria-live=\"polite\"\n                    aria-hidden={ariaHidden || isLabelMatchingTooltipText}\n                    data-testid=\"bdl-Tooltip\"\n                >\n                    {tooltipInner}\n                </div>\n            </div>\n        ) : (\n            <div\n                aria-live=\"polite\"\n                aria-hidden={ariaHidden || isLabelMatchingTooltipText}\n                className={classes}\n                data-testid=\"bdl-Tooltip\"\n                id={this.tooltipID}\n                onMouseEnter={this.handleMouseEnter}\n                onMouseLeave={this.handleMouseLeave}\n                role={theme === TooltipTheme.ERROR ? undefined : 'tooltip'}\n            >\n                {tooltipInner}\n            </div>\n        );\n\n        return (\n            <TetherComponent ref={this.tetherRef} {...tetherProps}>\n                {React.cloneElement(React.Children.only(children) as React.ReactElement, componentProps)}\n                {showTooltip && tooltip}\n            </TetherComponent>\n        );\n    }\n}\n\nexport default Tooltip;\n","import * as React from 'react';\nimport { injectIntl, IntlShape } from 'react-intl';\n\nimport IconClose from '../../icon/fill/X16';\nimport PlainButton from '../plain-button';\n\n// @ts-ignore flow import\nimport messages from '../../common/messages';\n\ntype Props = {\n    intl: IntlShape;\n    onClick: (event: React.SyntheticEvent<HTMLButtonElement, Event>) => void;\n};\n\nconst CloseButton = ({ intl, onClick }: Props) => (\n    <PlainButton aria-label={intl.formatMessage(messages.close)} className=\"tooltip-close-button\" onClick={onClick}>\n        <IconClose className=\"bdl-Tooltip-iconClose\" width={14} height={14} />\n    </PlainButton>\n);\n\nexport { CloseButton as CloseButtonBase };\nexport default injectIntl(CloseButton);\n","// @flow\nimport { defineMessages } from 'react-intl';\n\nconst messages = defineMessages({\n    cancel: {\n        defaultMessage: 'Cancel',\n        description: 'Cancel button text',\n        id: 'boxui.core.cancel',\n    },\n    close: {\n        defaultMessage: 'Close',\n        description: 'Close button text',\n        id: 'boxui.core.close',\n    },\n    copy: {\n        defaultMessage: 'Copy',\n        description: 'Copy button text',\n        id: 'boxui.core.copy',\n    },\n    copied: {\n        defaultMessage: 'Copied',\n        description: 'Copy button text after user clicks on it',\n        id: 'boxui.core.copied',\n    },\n    done: {\n        defaultMessage: 'Done',\n        description: 'Done button text',\n        id: 'boxui.core.done',\n    },\n    okay: {\n        defaultMessage: 'Okay',\n        description: 'Okay button text',\n        id: 'boxui.core.okay',\n    },\n    save: {\n        defaultMessage: 'Save',\n        description: 'Save button text',\n        id: 'boxui.core.save',\n    },\n    send: {\n        defaultMessage: 'Send',\n        description: 'Send button text',\n        id: 'boxui.core.send',\n    },\n    optional: {\n        defaultMessage: 'optional',\n        description: 'Optional text for labels',\n        id: 'boxui.core.optional',\n    },\n    pillSelectorPlaceholder: {\n        defaultMessage: 'Add names or email addresses',\n        description: 'Placeholder text for the pill selector',\n        id: 'boxui.share.pillSelectorPlaceholder',\n    },\n    messageSelectorPlaceholder: {\n        defaultMessage: 'Add a message',\n        description: 'Placeholder text for message section',\n        id: 'boxui.share.messageSelectorPlaceholder',\n    },\n    invalidInputError: {\n        defaultMessage: 'Invalid Input',\n        description: 'Generic error message for a field is invalid',\n        id: 'boxui.validation.genericError',\n    },\n    minLengthError: {\n        defaultMessage: 'Input must be at least {min} characters',\n        description: 'Error message for when an input value is too short. {min} is the minimum length',\n        id: 'boxui.validation.tooShortError',\n    },\n    maxLengthError: {\n        defaultMessage: 'Input cannot exceed {max} characters',\n        description: 'Error message for when an input value is too long. {max} is the maximum length',\n        id: 'boxui.validation.tooLongError',\n    },\n    invalidEmailError: {\n        defaultMessage: 'Invalid Email Address',\n        description: 'Error message for when an invalid email is entered',\n        id: 'boxui.validation.emailError',\n    },\n    invalidURLError: {\n        defaultMessage: 'Invalid URL',\n        description: 'Error message for when an invalid URL is entered',\n        id: 'boxui.validation.URLError',\n    },\n    invalidUserError: {\n        defaultMessage: 'Invalid User',\n        description: 'Error message for when an invalid user is entered',\n        id: 'boxui.validation.invalidUserError',\n    },\n    requiredFieldError: {\n        defaultMessage: 'Required Field',\n        description: 'Error message for when a required field is missing',\n        id: 'boxui.validation.requiredError',\n    },\n    invalidDateError: {\n        defaultMessage: 'Invalid Date',\n        description: 'Error message for when an invalid Date is entered',\n        id: 'boxui.validation.invalidDateError',\n    },\n});\n\nexport default messages;\n","// @flow\nimport * as React from 'react';\n\nimport IconCaretDown from '../../icons/general/IconCaretDown';\n\nimport './MenuToggle.scss';\n\ntype Props = {\n    children?: React.Node,\n};\n\nconst MenuToggle = ({ children }: Props) => (\n    <span className=\"menu-toggle\">\n        {children}\n        <IconCaretDown className=\"toggle-arrow\" width={7} />\n    </span>\n);\n\nexport default MenuToggle;\n","import * as React from 'react';\nimport classNames from 'classnames';\nimport omit from 'lodash/omit';\n\nimport RadarAnimation from '../radar';\n\nexport interface MenuItemProps {\n    /** 'aria-checked' - ARIA attribute for checkbox elements */\n    'aria-checked'?: boolean;\n    /** 'aria-disabled' - ARIA attribute describing whether the menu item is disabled */\n    'aria-disabled'?: boolean | 'true' | 'false';\n    /** children - menu item content */\n    children?: Array<React.ReactChild> | React.ReactChild;\n    /** className - CSS class name for the menu item */\n    className?: string;\n    /** isDisabled - whether the menu item is disabled */\n    isDisabled?: boolean;\n    /** isSelectItem - whether the menu item is a checkbox element */\n    isSelectItem?: boolean;\n    /** isSelected - whether the menu item is selected */\n    isSelected?: boolean;\n    /** onClick - function called when the menu item is clicked */\n    onClick?: (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => void;\n    /** role - ARIA role for the menu item */\n    role?: string;\n    /** showRadar - whether the radar component is shown */\n    showRadar?: boolean;\n    /** tabIndex - indicator of whether the menu item is focusable */\n    tabIndex?: number;\n}\n\nclass MenuItem extends React.Component<MenuItemProps> {\n    onClickHandler = (event: React.MouseEvent<HTMLLIElement, MouseEvent>) => {\n        const { isDisabled, onClick } = this.props;\n\n        // If aria-disabled is passed as a prop, we should ignore clicks on this menu item\n        if (isDisabled) {\n            event.stopPropagation();\n            event.preventDefault();\n\n            return;\n        }\n\n        if (onClick) {\n            onClick(event);\n        }\n    };\n\n    render() {\n        const { children, className, isDisabled, isSelectItem, isSelected, showRadar, ...rest } = this.props;\n        const menuItemProps: MenuItemProps = omit(rest, ['role', 'tabIndex', 'onClick']);\n\n        menuItemProps.className = classNames('menu-item', className, {\n            'is-select-item': isSelectItem,\n            'is-selected': isSelected,\n        });\n        menuItemProps.role = isSelectItem ? 'menuitemradio' : 'menuitem';\n        menuItemProps.tabIndex = -1;\n        menuItemProps.onClick = this.onClickHandler;\n\n        if (isSelectItem) {\n            menuItemProps['aria-checked'] = isSelected;\n        }\n\n        if (isDisabled) {\n            menuItemProps['aria-disabled'] = 'true';\n        }\n\n        let menuItem = <li {...menuItemProps}>{children}</li>;\n        if (showRadar) {\n            menuItem = <RadarAnimation>{menuItem}</RadarAnimation>;\n        }\n\n        return menuItem;\n    }\n}\n\nexport default MenuItem;\n","// @flow\nimport * as React from 'react';\nimport noop from 'lodash/noop';\n\ntype MenuContextValues = {\n    closeMenu: Function;\n};\n\nexport default React.createContext<MenuContextValues>({ closeMenu: noop });\n","/**\n * @flow\n * @file Wrapper to conditionally add a tooltip\n * @author Box\n */\n\nimport * as React from 'react';\nimport TooltipCore from '../../components/tooltip/Tooltip';\n\nconst Tooltip = ({\n    children,\n    isDisabled,\n    text,\n    ...rest\n}: {\n    children: React.Node,\n    isDisabled?: boolean,\n    text?: ?string | React.Node,\n}) => {\n    if (isDisabled || !text) {\n        return children;\n    }\n\n    return (\n        <TooltipCore text={text} {...rest}>\n            {children}\n        </TooltipCore>\n    );\n};\n\nexport default Tooltip;\n","// @flow\nimport * as React from 'react';\nimport TetherComponent from 'react-tether';\nimport classNames from 'classnames';\nimport noop from 'lodash/noop';\nimport uniqueId from 'lodash/uniqueId';\n\nimport { KEYS } from '../../constants';\nimport './DropdownMenu.scss';\n\ntype Props = {\n    bodyElement?: HTMLElement,\n    children: React.Node,\n    /** Forces menu to render within the scroll parent */\n    className?: string,\n    /** Forces menu to render within the visible window */\n    constrainToScrollParent: boolean,\n    /** Right aligns menu to button */\n    constrainToWindow: boolean,\n    /** Forces menu to render within the visible window and pins the dropdown if scrolled */\n    constrainToWindowWithPin?: boolean,\n    /** Enables responsive behaviors for this component */\n    isResponsive?: boolean,\n    /** Function called when menu is opened */\n    isRightAligned: boolean,\n    /** Handler for dropdown menu close events */\n    onMenuClose?: (event: SyntheticEvent<> | MouseEvent) => void,\n    /** Handler for dropdown menu open events */\n    onMenuOpen?: () => void,\n    /** \"attachment\" prop for the TetherComponent, will overwrite the default settings and ignore isRightAligned option */\n    tetherAttachment?: string,\n    /** \"targetAttachment\" prop for the TetherComponent, will overwrite the default settings and ignore isRightAligned option */\n    tetherTargetAttachment?: string,\n    /** Set true to close dropdown menu on event bubble instead of event capture */\n    useBubble?: boolean,\n};\n\ntype State = {\n    initialFocusIndex: ?number,\n    isOpen: boolean,\n};\n\nclass DropdownMenu extends React.Component<Props, State> {\n    static defaultProps = {\n        constrainToScrollParent: false,\n        constrainToWindow: false,\n        isResponsive: false,\n        isRightAligned: false,\n    };\n\n    menuID = uniqueId('menu');\n\n    menuButtonID = uniqueId('menubutton');\n\n    state = {\n        initialFocusIndex: null,\n        isOpen: false,\n    };\n\n    componentDidUpdate(prevProps: Props, prevState: State) {\n        const { useBubble } = this.props;\n        if (!prevState.isOpen && this.state.isOpen) {\n            // When menu is being opened\n            document.addEventListener('click', this.handleDocumentClick, !useBubble);\n            document.addEventListener('contextmenu', this.handleDocumentClick, !useBubble);\n\n            const { onMenuOpen } = this.props;\n            if (onMenuOpen) {\n                onMenuOpen();\n            }\n        } else if (prevState.isOpen && !this.state.isOpen) {\n            // When menu is being closed\n            document.removeEventListener('contextmenu', this.handleDocumentClick, !useBubble);\n            document.removeEventListener('click', this.handleDocumentClick, !useBubble);\n        }\n    }\n\n    componentWillUnmount() {\n        const { useBubble } = this.props;\n        if (this.state.isOpen) {\n            // Clean-up global click handlers\n            document.removeEventListener('contextmenu', this.handleDocumentClick, !useBubble);\n            document.removeEventListener('click', this.handleDocumentClick, !useBubble);\n        }\n    }\n\n    menuID: string;\n\n    menuButtonID: string;\n\n    openMenuAndSetFocusIndex = (initialFocusIndex: ?number) => {\n        this.setState({\n            initialFocusIndex,\n            isOpen: true,\n        });\n    };\n\n    closeMenu = (event: SyntheticEvent<> | MouseEvent) => {\n        const { onMenuClose = noop } = this.props;\n        this.setState(\n            {\n                isOpen: false,\n            },\n            () => onMenuClose(event),\n        );\n    };\n\n    focusButton = () => {\n        // @NOTE: This breaks encapsulation a bit, but the only other way is passing ref functions to unknown children components\n        const menuButtonEl = document.getElementById(this.menuButtonID);\n        if (menuButtonEl) {\n            menuButtonEl.focus();\n        }\n    };\n\n    handleButtonClick = (event: SyntheticEvent<>) => {\n        const { isOpen } = this.state;\n\n        event.stopPropagation();\n        event.preventDefault();\n\n        if (isOpen) {\n            this.closeMenu(event);\n        } else {\n            this.openMenuAndSetFocusIndex(null);\n        }\n    };\n\n    handleButtonKeyDown = (event: SyntheticKeyboardEvent<>) => {\n        const { isOpen } = this.state;\n\n        switch (event.key) {\n            case KEYS.space:\n            case KEYS.enter:\n            case KEYS.arrowDown:\n                event.stopPropagation();\n                event.preventDefault();\n\n                this.openMenuAndSetFocusIndex(0);\n                break;\n\n            case KEYS.arrowUp:\n                event.stopPropagation();\n                event.preventDefault();\n\n                this.openMenuAndSetFocusIndex(-1);\n                break;\n\n            case KEYS.escape:\n                if (isOpen) {\n                    event.stopPropagation();\n                }\n\n                event.preventDefault();\n                this.closeMenu(event);\n                break;\n\n            default:\n                break;\n        }\n    };\n\n    handleMenuClose = (isKeyboardEvent: boolean, event: SyntheticEvent<> | MouseEvent) => {\n        this.closeMenu(event);\n        this.focusButton();\n    };\n\n    handleDocumentClick = (event: MouseEvent) => {\n        const menuEl = document.getElementById(this.menuID);\n        const menuButtonEl = document.getElementById(this.menuButtonID);\n\n        // Some DOM magic to get global click handlers to close menu when not interacting with menu or associated button\n        if (\n            menuEl &&\n            menuButtonEl &&\n            event.target instanceof Node &&\n            !menuEl.contains(event.target) &&\n            !menuButtonEl.contains(event.target)\n        ) {\n            this.closeMenu(event);\n        }\n    };\n\n    render() {\n        const {\n            bodyElement,\n            children,\n            className,\n            constrainToScrollParent,\n            constrainToWindow,\n            constrainToWindowWithPin,\n            isResponsive,\n            isRightAligned,\n            tetherAttachment,\n            tetherTargetAttachment,\n        } = this.props;\n\n        const { isOpen, initialFocusIndex } = this.state;\n\n        const elements = React.Children.toArray(children);\n\n        if (elements.length !== 2) {\n            throw new Error('DropdownMenu must have exactly two children: A button component and a <Menu>');\n        }\n\n        const menuButton = elements[0];\n        const menu = elements[1];\n\n        const menuButtonProps: Object = {\n            id: this.menuButtonID,\n            key: this.menuButtonID,\n            onClick: this.handleButtonClick, // NOTE: Overrides button's handler\n            onKeyDown: this.handleButtonKeyDown, // NOTE: Overrides button's handler\n            'aria-expanded': isOpen ? 'true' : 'false',\n        };\n\n        if (menuButton.props['aria-haspopup'] === undefined) {\n            menuButtonProps['aria-haspopup'] = 'true';\n        }\n\n        // Add this only when its open, otherwise the menuID element isn't rendered\n        if (isOpen) {\n            menuButtonProps['aria-controls'] = this.menuID;\n        }\n\n        const menuProps = {\n            id: this.menuID,\n            key: this.menuID,\n            initialFocusIndex,\n            onClose: this.handleMenuClose,\n            'aria-labelledby': this.menuButtonID,\n        };\n\n        let attachment = 'top left';\n        let targetAttachment = 'bottom left';\n\n        if (isRightAligned) {\n            attachment = 'top right';\n            targetAttachment = 'bottom right';\n        }\n\n        const constraints = [];\n\n        if (constrainToScrollParent) {\n            constraints.push({\n                to: 'scrollParent',\n                attachment: 'together',\n            });\n        }\n\n        if (constrainToWindow) {\n            constraints.push({\n                to: 'window',\n                attachment: 'together',\n            });\n        }\n\n        if (constrainToWindowWithPin) {\n            constraints.push({\n                to: 'window',\n                attachment: 'together',\n                pin: true,\n            });\n        }\n\n        const bodyEl = bodyElement instanceof HTMLElement ? bodyElement : document.body;\n\n        return (\n            <TetherComponent\n                attachment={tetherAttachment || attachment}\n                bodyElement={bodyEl}\n                className={classNames({ 'bdl-DropdownMenu--responsive': isResponsive }, className)}\n                classPrefix=\"dropdown-menu\"\n                constraints={constraints}\n                enabled={isOpen}\n                targetAttachment={tetherTargetAttachment || targetAttachment}\n            >\n                {React.cloneElement(menuButton, menuButtonProps)}\n                {isOpen && React.cloneElement(menu, menuProps)}\n            </TetherComponent>\n        );\n    }\n}\n\nexport default DropdownMenu;\n","import * as React from 'react';\n\nimport AccessibleSVG from '../accessible-svg';\n\nimport { Icon } from '../iconTypes';\n\nconst IconCaretDown = ({ className = '', color = '#000', height = 6, title, width = 10 }: Icon) => (\n    <AccessibleSVG\n        className={`icon-caret-down ${className}`}\n        height={height}\n        title={title}\n        viewBox=\"0 0 10 6\"\n        width={width}\n    >\n        <path className=\"fill-color\" d=\"M0 .5l5 5 5-5H0z\" fill={color} fillRule=\"evenodd\" />\n    </AccessibleSVG>\n);\n\nexport default IconCaretDown;\n","import * as React from 'react';\nimport omit from 'lodash/omit';\nimport classNames from 'classnames';\n\nimport MenuContext from './MenuContext';\n\nimport './Menu.scss';\n\n/**\n * The selectors are used to identify the menu item that is selected. We need to eventually\n * rewrite this logic as there seem to be strong coupling between the selector and MenuItem\n * that we want to decouple. The span is here to allow Menu to recognize MenuItem even if it is\n * wrapped by a span coming from a tooltip.\n */\nconst MENU_ITEM_SELECTOR = '.menu-item:not([aria-disabled])';\nconst TOP_LEVEL_MENU_ITEM_SELECTOR = `ul:not(.submenu) > ${MENU_ITEM_SELECTOR}, ul:not(.submenu) > li > ${MENU_ITEM_SELECTOR}, ul:not(.submenu) > span > ${MENU_ITEM_SELECTOR}`;\nconst SUBMENU_ITEM_SELECTOR = `ul.submenu > ${MENU_ITEM_SELECTOR}, ul.submenu > li > ${MENU_ITEM_SELECTOR}, ul.submenu > span > ${MENU_ITEM_SELECTOR}`;\n\nfunction stopPropagationAndPreventDefault(event: React.KeyboardEvent<HTMLElement>) {\n    event.stopPropagation();\n    event.preventDefault();\n}\n\ninterface MenuProps {\n    /** children - menu items */\n    children: Array<React.ReactNode> | Array<React.ReactChild> | React.ReactChild;\n    /** className - CSS class name for the menu */\n    className: string;\n    /** initialFocusIndex - focuses a specific menu item index when menu is mounted */\n    initialFocusIndex?: number;\n    /** isHidden - whether the menu’s content is hidden */\n    isHidden?: boolean;\n    /** isSubmenu - whether this is a submenu of another menu */\n    isSubmenu?: boolean;\n    /** menuItemSelector - overrides the default menu selector */\n    menuItemSelector?: string;\n    /** onClick - function called when the menu is clicked */\n    onClick?: (event: React.MouseEvent<HTMLUListElement, MouseEvent>) => void;\n    /** onClick - function called when the menu is closed */\n    onClose?: (\n        isKeyboardEvent?: boolean,\n        event?: React.MouseEvent<HTMLUListElement, MouseEvent> | React.KeyboardEvent<HTMLElement>,\n    ) => void;\n    /** onClick - function called when a key is pressed within the menu */\n    onKeyDown?: (event: React.KeyboardEvent<HTMLUListElement>) => void;\n    /** ref - reference to the menu element in the DOM */\n    ref?: string | ((instance: HTMLUListElement | null) => void) | React.RefObject<HTMLUListElement> | null | undefined;\n    /** role - ARIA role for the menu */\n    role?: string;\n    /** setRef - will fire this callback when menu should \"close' */\n    setRef?: Function;\n    /** shouldOutlineFocus - whether the focused menu item should have an outline */\n    shouldOutlineFocus?: boolean;\n    /** tabIndex - indicator of whether the menu is focusable */\n    tabIndex?: number;\n}\n\nclass Menu extends React.Component<MenuProps> {\n    static defaultProps = {\n        className: '',\n        isSubmenu: false,\n        isHidden: false,\n    };\n\n    constructor(props: MenuProps) {\n        super(props);\n\n        this.focusIndex = 0;\n        this.menuEl = null;\n        this.menuItemEls = [];\n    }\n\n    componentDidMount() {\n        this.setMenuItemEls();\n        this.setInitialFocusIndex();\n    }\n\n    componentDidUpdate({ isHidden: prevIsHidden, children: prevChildren }: MenuProps) {\n        const { children, isHidden, isSubmenu } = this.props;\n\n        if (isSubmenu && prevIsHidden && !isHidden) {\n            // If updating submenu, use the current props instead of previous props.\n            this.setMenuItemEls();\n            this.setInitialFocusIndex(this.props);\n        }\n\n        // update focus index and menu item elements when the number of children changes\n        if (React.Children.toArray(prevChildren).length !== React.Children.toArray(children).length) {\n            const focusedMenuItemEl = this.menuItemEls[this.focusIndex];\n            this.setMenuItemEls();\n            const { menuIndex } = this.getMenuItemElFromEventTarget(focusedMenuItemEl);\n\n            const isFocusedElementMissing = menuIndex === -1;\n            const isFocusIndexOutOfBounds = this.focusIndex >= this.menuItemEls.length;\n\n            this.setFocus(isFocusedElementMissing && !isFocusIndexOutOfBounds ? this.focusIndex : menuIndex);\n        }\n    }\n\n    setInitialFocusIndex = (props: MenuProps = this.props) => {\n        const { initialFocusIndex, isHidden } = props;\n\n        if (isHidden || initialFocusIndex === undefined) {\n            return;\n        }\n\n        // If an initialFocusIndex was specified, attempt to use it to focus\n        if (typeof initialFocusIndex === 'number') {\n            // We do this after a timeout so that the menu is properly mounted before we attempt to focus it\n            setTimeout(() => {\n                this.setFocus(initialFocusIndex);\n            }, 0);\n        } else if (initialFocusIndex === null) {\n            // If no initial focus index is set, focus on the menu itself so that keyboard shortcut still works after a mouse click.\n            setTimeout(() => {\n                if (this.menuEl) {\n                    this.menuEl.focus();\n                }\n            }, 0);\n        }\n    };\n\n    setMenuItemEls = () => {\n        const { isSubmenu, menuItemSelector } = this.props;\n\n        const selector = menuItemSelector || (isSubmenu ? SUBMENU_ITEM_SELECTOR : TOP_LEVEL_MENU_ITEM_SELECTOR);\n        // Keep track of all the valid menu items that were rendered (querySelector since we don't want to pass ref functions to every single child)\n        this.menuItemEls = this.menuEl ? [].slice.call(this.menuEl.querySelectorAll(selector)) : [];\n    };\n\n    getMenuItemElFromEventTarget = (\n        target: Node,\n    ): {\n        menuItemEl?: HTMLElement | null;\n        menuIndex: number;\n    } => {\n        let menuItemEl = null;\n        let menuIndex = -1;\n\n        for (let i = 0; i < this.menuItemEls.length; i += 1) {\n            if (this.menuItemEls[i].contains(target)) {\n                menuItemEl = this.menuItemEls[i];\n                menuIndex = i;\n                break;\n            }\n        }\n        return { menuItemEl, menuIndex };\n    };\n\n    setFocus = (index: number) => {\n        if (!this.menuItemEls.length) {\n            return;\n        }\n\n        const numMenuItems = this.menuItemEls.length;\n\n        if (index >= numMenuItems) {\n            this.focusIndex = 0;\n        } else if (index < 0) {\n            this.focusIndex = numMenuItems - 1;\n        } else {\n            this.focusIndex = index;\n        }\n\n        this.menuItemEls[this.focusIndex].focus();\n    };\n\n    focusIndex: number;\n\n    keyboardPressed: boolean | null | undefined;\n\n    menuEl: HTMLUListElement | null | undefined;\n\n    menuItemEls: Array<HTMLElement>;\n\n    focusFirstItem = () => {\n        this.setFocus(0);\n    };\n\n    focusLastItem = () => {\n        this.setFocus(-1);\n    };\n\n    focusNextItem = () => {\n        this.setFocus(this.focusIndex + 1);\n    };\n\n    focusPreviousItem = () => {\n        this.setFocus(this.focusIndex - 1);\n    };\n\n    fireOnCloseHandler = (\n        isKeyboardEvent?: boolean,\n        event?: React.MouseEvent<HTMLUListElement, MouseEvent> | React.KeyboardEvent<HTMLElement>,\n    ) => {\n        const { onClose } = this.props;\n\n        if (onClose) {\n            // We need to pass the event type so we know which item to focus.\n            onClose(isKeyboardEvent, event);\n        }\n    };\n\n    handleClick = (event: React.MouseEvent<HTMLUListElement, MouseEvent>) => {\n        const { menuItemEl }: { menuItemEl?: HTMLElement | null } =\n            event.target instanceof Node ? this.getMenuItemElFromEventTarget(event.target) : {};\n\n        if (!menuItemEl) {\n            return;\n        }\n        this.fireOnCloseHandler(false, event);\n    };\n\n    handleKeyDown = (event: React.KeyboardEvent<HTMLElement>) => {\n        const { isSubmenu, initialFocusIndex } = this.props;\n\n        switch (event.key) {\n            case 'ArrowDown':\n                stopPropagationAndPreventDefault(event); // If it's first keyboard event, focus on first item.\n\n                if (initialFocusIndex === null && !this.keyboardPressed) {\n                    this.focusFirstItem();\n                } else {\n                    this.focusNextItem();\n                }\n\n                break;\n\n            case 'ArrowUp':\n                stopPropagationAndPreventDefault(event);\n                this.focusPreviousItem();\n                break;\n\n            case 'ArrowLeft':\n                // Close submenu when arrow-left is clicked\n                if (!isSubmenu) {\n                    return;\n                }\n\n                stopPropagationAndPreventDefault(event);\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case 'Home':\n            case 'PageUp':\n                stopPropagationAndPreventDefault(event);\n                this.focusFirstItem();\n                break;\n\n            case 'End':\n            case 'PageDown':\n                stopPropagationAndPreventDefault(event);\n                this.focusLastItem();\n                break;\n\n            case 'Escape':\n                stopPropagationAndPreventDefault(event);\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case 'Tab':\n                // DO NOT PREVENT DEFAULT OR STOP PROPAGATION - This should move focus natively\n                this.fireOnCloseHandler(true, event);\n                break;\n\n            case ' ':\n            case 'Enter':\n                stopPropagationAndPreventDefault(event);\n\n                if (event.target instanceof HTMLElement) {\n                    event.target.click();\n                }\n\n                break;\n\n            default:\n                break;\n        }\n\n        this.keyboardPressed = true;\n    };\n\n    render() {\n        const { children, className, isHidden, setRef, shouldOutlineFocus, ...rest } = this.props;\n\n        const menuProps = omit(rest, ['onClose', 'initialFocusIndex', 'isSubmenu', 'menuItemSelector']) as MenuProps;\n        menuProps.className = classNames('aria-menu', className, {\n            'is-hidden': isHidden,\n            'should-outline-focus': shouldOutlineFocus,\n        });\n        menuProps.ref = (ref: HTMLUListElement | null) => {\n            this.menuEl = ref;\n            if (setRef) {\n                setRef(ref);\n            }\n        };\n        if (menuProps.role === undefined) {\n            menuProps.role = 'menu';\n        }\n        menuProps.tabIndex = -1;\n        menuProps.onClick = this.handleClick;\n        menuProps.onKeyDown = this.handleKeyDown;\n\n        return (\n            <ul {...menuProps}>\n                <MenuContext.Provider value={{ closeMenu: this.fireOnCloseHandler }}>{children}</MenuContext.Provider>\n            </ul>\n        );\n    }\n}\n\nexport default Menu;\n"],"sourceRoot":""}